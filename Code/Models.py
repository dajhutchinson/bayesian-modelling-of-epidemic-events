import matplotlib.pyplot as plt
import numpy as np
from scipy import stats

class Model():

    def __init__(self):
        """
        DESCRIPTION
        generative models which I shall perform Approximate Bayesian Computation on.
        """
        raise NotImplementedError

        # all models have the following
        self.n_params=int # number of parameters
        self.params=list(float) # parameter values

        self.n_obs=int # number of observations made by `observe`
        self.dim_obs=int # dimension of each observation

        self.noise=float # variance of additive gaussian noise (default=0)

    def update_params(self,new_params:[float]):
        """
        DESCRIPTION
        update the parameters of the model. the observations for `observe` need to be recalculated

        PARAMETERS
        new_paramas ([float]) - new parameter values
        """
        raise NotImplementedError

    def observe(self,noise=True) -> [[float]]:
        """
        DESCRIPTION
        generate a sequence of `n_obs` observations from the model, each of dimension `dim_obs`.
        The same sequence is returned each time this function is called.
        sequence is ordered by `x_obs` so is best for `x_obs` to provide a useful ordering.

        PARAMETERS
        None

        RETURNS
        [[float]] - sequence of observations
        """
        raise NotImplementedError

    def copy(self,new_params:[float]) -> "Model":
        """
        DESCRIPTION
        create a copy of the model with new parameter values

        PARAMETERS
        new_params ([float]) - new parameter values

        RETURNS
        Model - New copy, with stated parameter values
        """
        raise NotImplementedError

    def plot_obs(self):
        """
        DESCRIPTION
        generate plots of observations returned by `observe`. There is a different plot for each dimension.

        PARAMETERS
        None

        RETURNS
        None
        """
        fig=plt.figure()
        plt.subplots_adjust(left=.05,right=.95,bottom=.05,top=.95)

        x=list(range(self.n_obs))
        y_obs=self.observe()

        for i in range(self.dim_obs):
            y_obs_dim=[y[i] for y in y_obs]
            ax=fig.add_subplot(1,self.dim_obs,i+1)
            ax.set_title("Dim {}".format(i+1))
            ax.scatter(x,y_obs_dim)

        plt.show()

    def plot_obs_dim(self,dim:int,ax=None) -> plt.Axes:
        """
        DESCRIPTION
        Plot results of specific dimension of the observations from `observe`.

        PARAMETERS
        dim (int) - dimension you wish to plot.
        ax (plt.Axes) - Axes to make plot on (optional).

        RETURNS
        plt.Axes - axes containing new plot
        """
        if (type(dim)!=int): raise TypeError("`dim` must be an interger (not {})".format(type(dim)))
        if (dim<0 or dim>=self.dim_obs): raise ValueError("`dim` is out of range (exp in [0,{}])".format(self.dim_obs-1))

        show=False
        if (not ax):
            ax=plt.axes()
            show=True

        x=list(range(self.n_obs))
        y_obs=self.observe()

        y_obs_dim=[y[dim] for y in y_obs]
        ax.set_title("Dim {}".format(dim+1))
        ax.scatter(x,y_obs_dim)

        if (show): plt.show()

        return ax

class LinearModel(Model): # a+bx+cy+...

    def __init__(self,n_params:int,params:[float],n_vars:int,n_obs:int,x_obs:[[float]],noise=None):
        """
        DESCRIPTION

        PARAMETERS
        n_params (int) - number of parameters in model.
        params ([float]) - parameters of the model
        n_vars (int) - number of varaibles in model.
        n_obs (int) - number of observations generated by `observe()`
        x_obs ([[float]]) - variable values used in observations (dim = n_obs*n_vars)

        OPTIONAL PARAMETERS
        noise - variance of additive gaussian noise (default=None)
        """

        # valid inputs
        if not all([type(x)==int for x in [n_params,n_vars,n_obs]]): raise TypeError("n_params,n_vars,n_obs should all be integers.")
        if not all([x>=0 for x in [n_params,n_vars,n_obs]]): raise ValueError("n_params,n_vars,n_obs should all be >=0.")
        if (len(params)!=n_params): raise ValueError("Incorrect number of parameters passed. len(params)!=n_params.")
        if (n_vars+1!=n_params): raise ValueError("Expected one more parameter than variable.")
        if (len(x_obs)!=n_obs): raise ValueError("Inccorect number of observation points given. len(x_obs)!=n_obs.")
        if not all([len(x_obs_i)==n_vars for x_obs_i in x_obs]): raise TypeError("All elements of x_obs should have dimension n_vars ({})".formt(n_vars))
        if (noise) and (noise<0): raise ValueError("`noise` must be non-negative.")

        # specify model
        self.n_params=n_params
        self.params=params
        self.n_vars=n_vars
        self.n_obs=n_obs
        self.x_obs=x_obs
        self.dim_obs=1

        self.noise_var=noise if (noise) else 0
        self.add_noise=(lambda : stats.norm(0,np.sqrt(self.noise_var)).rvs(1)[0])

        # observations
        self.observations=[self.__calc(x) for x in self.x_obs]

    def update_params(self,new_params):
        """
        DESCRIPTION
        update the parameters of the model. the observations for `observe` need to be recalculated

        PARAMETERS
        new_paramas ([float]) - new parameter values
        """
        if (len(new_params)!=self.n_params): raise ValueError("Incorrect number of parameters passed. len(params)!=n_params.")

        self.params=new_params
        # update observations observations
        self.observations=[self.__calc(x) for x in self.x_obs]

    def observe(self,inc_noise=True) -> [[float]]:
        """
        DESCRIPTION
        generate a sequence of `n_obs` observations from the model, each of dimension `dim_obs`.
        The same sequence is returned each time this function is called/

        PARAMETERS
        inc_noise (bool) - whether to include noise in returned value (default=True)

        Returns
        [[float]] - sequence of observations (For LinearModel each observation is a 1d list)
        """
        if (inc_noise): return self.observations
        return [self.__calc(x,False) for x in self.x_obs]

    def __calc(self,x:[float],inc_noise=True) -> [float]:
        """
        DESCRIPTION
        calculate the value of an observation at a specific point `x` in the varaible space.

        PARAMETERS
        x ([float]) - point to observe model at (len(x)=n_vars)

        OPTIONAL PARAMETERS
        inc_noise (bool) - whether to include noise in calculation (default=True)

        Returns
        [[float]] - value of model at observed point (for LinearModel this is a 1d list)
        """
        # valid x is in the model's variable space
        if (type(x)!=list): raise TypeError("`x` must be a `list` (not `{}`)".format(type(x)))
        if (len(x)!=self.n_vars): raise TypeError("`x` is of wrong dimension (Exp={})".format(len(x)))

        # calculate value
        y=self.params[0]
        for (x,param) in zip(x,self.params[1:]):
            y+=param*x
        if (inc_noise): y+=self.add_noise()
        return [y]

    def copy(self,new_params:[float]) -> "LinearModel":
        """
        DESCRIPTION
        create a copy of the model with new parameter values.
        does NOT copy noise over

        PARAMETERS
        new_params ([float]) - new parameter values

        RETURNS
        LinearModel - New copy, with stated parameter values
        """

        if (type(new_params)!=list): raise TypeError("`new_params` shoud be a list (not {})".format(type(new_params)))
        if (len(new_params)!=self.n_params): raise TypeError("`new_params` shoud of length `n_params` ({})".format(self.n_params))

        new_model=LinearModel(self.n_params,new_params,self.n_vars,self.n_obs,self.x_obs)
        return new_model

    def __str__(self):
        print_str="{:.3f}".format(self.params[0])
        for (i,p) in enumerate(self.params[1:]):
            if (p<0): print_str+="{:.3f}*x{:.3f}".format(p,i)
            elif (p>0): print_str+="+{:.3f}*x{}".format(p,i)

        if (self.noise_var!=0): print_str+="+N(0,{:.3f})".format(self.noise_var)
        return print_str

class ExponentialModel(Model): # ae^{xb}

    def __init__(self,params:[float],n_obs:int,x_obs:[[float]],noise=None):
        """
        DESCRIPTION

        PARAMETERS
        n_params (int) - number of parameters in model.
        params ([float]) - parameters of the model
        n_obs (int) - number of observations generated by `observe()`
        x_obs ([[float]]) - variable values used in observations (dim = n_obs*n_vars)

        OPTIONAL PARAMETERS
        noise - variance of additive gaussian noise (default=None)
        """

        # valid inputs
        if not all([type(x)==int for x in [n_obs]]): raise TypeError("n_obs should all be integers.")
        if not all([x>=0 for x in [n_obs]]): raise ValueError("n_obs should all be >=0.")
        if (len(params)!=2): raise ValueError("Incorrect number of parameters passed. len(params)!=2.")
        if (len(x_obs)!=n_obs): raise ValueError("Inccorect number of observation points given. len(x_obs)!=n_obs.")
        if not all([len(x_obs_i)==1 for x_obs_i in x_obs]): raise TypeError("All elements of x_obs should have dimension n_vars ({})".formt(1))

        # specify model
        self.n_params=2
        self.params=params
        self.n_vars=1
        self.n_obs=n_obs
        self.x_obs=x_obs
        self.dim_obs=1

        self.noise_var=noise if (noise) else 0
        self.add_noise=(lambda : stats.norm(0,np.sqrt(self.noise_var)).rvs(1)[0])

        # observations (ensure same noise each time `observe is called`)
        self.observations=[self.__calc(x) for x in x_obs]

    def update_params(self,new_params):
        """
        DESCRIPTION
        update the parameters of the model. the observations for `observe` need to be recalculated

        PARAMETERS
        new_paramas ([float]) - new parameter values
        """
        if (len(new_params)!=self.n_params): raise ValueError("Incorrect number of parameters passed. len(params)!=n_params.")

        self.params=new_params
        # update observations observations
        self.observations=[self.__calc(x) for x in self.x_obs]

    def observe(self,inc_noise=True) -> [[float]]:
        """
        DESCRIPTION
        generate a sequence of `n_obs` observations from the model, each of dimension `dim_obs`.
        The same sequence is returned each time this function is called/

        PARAMETERS
        None

        Returns
        [[float]] - sequence of observations (For LinearModel each observation is a 1d list)
        """
        if (inc_noise): return self.observations
        return [self.__calc(x,False) for x in self.x_obs]

    def __calc(self,x:[float],inc_noise=True) -> [float]:
        """
        DESCRIPTION
        calculate the value of an observation at a specific point `x` in the varaible space.

        PARAMETERS
        inc_noise (bool) - whether to include noise in calculation (default=True)

        OPTIONAL PARAMETERS
        inc_noise (bool) -

        Returns
        [[float]] - value of model at observed point (for ExponentialModel this is a 1d list)
        """
        # valid x is in the model's variable space
        if (type(x)!=list): raise TypeError("`x` must be a `list` (not `{}`)".format(type(x)))
        if (len(x)!=self.n_vars): raise TypeError("`x` is of wrong dimension (Exp={})".format(len(x)))

        # calculate value
        y=[self.params[0]+np.exp(x[0]*self.params[1])]
        if (inc_noise): y+=self.add_noise()
        return y

    def copy(self,new_params:[float]) -> "ExponentialModel":
        """
        DESCRIPTION
        create a copy of the model with new parameter values

        PARAMETERS
        new_params ([float]) - new parameter values

        RETURNS
        ExponentialModel - New copy, with stated parameter values
        """

        if (type(new_params)!=list): raise TypeError("`new_params` shoud be a list (not {})".format(type(new_params)))
        if (len(new_params)!=self.n_params): raise TypeError("`new_params` shoud of length `n_params` ({})".format(self.n_params))

        new_model=ExponentialModel(new_params,self.n_obs,self.x_obs)
        return new_model

    def __str__(self):
        printing_str="{:.3f}*e^({:.3f}x)".format(self.params[0],self.params[1])
        if (self.noise_var!=0): printing_str+="+N(0,{:.3f})".format(self.noise_var)
        return printing_str
